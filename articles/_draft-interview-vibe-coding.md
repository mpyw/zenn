# インタビュー記録: Linter 開発 × Vibe Coding

※ 記事のおまけ用に生のやり取りを記録

---

## Q1. 記事の背景・動機

**Claude:** まず「Vibe Coding」という言葉について確認させてください。

- Vibe Coding は「AI に雰囲気（vibe）で指示を出してコードを書かせる」というニュアンスで合っていますか？
- この記事を書こうと思ったきっかけは何ですか？

**mpyw:** Vibe Coding は AI に雰囲気で指示出して開発するっていうそういうニュアンスで合ってる

---

## Q2. なぜ「Linter 開発」が Vibe Coding に適しているのか

**Claude:** この記事のコアとなる主張について聞かせてください。

- Linter 開発が Vibe Coding に特に向いていると考える理由は何ですか？
- 例えば「入力と出力が明確」「テストケースが書きやすい」「go/ast や go/types の知識が必要だが AI が得意」など，思いつく要因があれば教えてください。

**mpyw:**

1. 合っています。ただ巷で言われていた「No Code」や「素人が何でも作れる」というよりは，基礎力を活かして AI のハルシネーションを是正しながら正しい方向に導くスキルは絶対に必要だし，その裏付けとしてこれまで培ってきた経験が腐ることはないと信じています。
きっかけは・・・1〜2週間であまりにも Vibe Coding がはかどりすぎてライブラリ5本，記事2本も出してしまったので，この体験自体を共有する記事を書きたい！これなら２５日目のテーマとしてもええやろ，みんな Vibe Coding 関心あるやろしｗみたいな感じです

2.
まずこれは Linter に関わらず言えることですが， AI の出力は確率的に変化します。モデルの性能が良ければ，毎回それっぽい結果に収束するようにはなっていると思いますが，その中でも毎回僅かに構成や微妙なニュアンスの違いが含まれていることはあると思います。またタスクの難易度によっても期待した出力が得られる確率は変動します。
そういった中でハズレ値として不正確な内容を引いてしまったときのことを考えましょう。レビュアーが優秀で，レビューできる範囲のコード量だったらいいのですが，AIを使っている時点で「自分がやるのはしんどい物量」「自分が技術的に到達しきいっていない領域」を任せることが多く，その出力すべてを理解するには常に困難が付き纏います。

それを助けてくれる救世主が TDD (Test Driven Development) です。ある入力に対してこういう出力が得られる，というのをあらかじめスタブのテストとして書いておき，それをパスするように作る，という手法です。
一般化して実装するのが人間にとって難しい領域であったとしても，具体例をいくつか挙げることぐらいは，まだ人間にとっても着手しやすいことが多いでしょう。AIのお膳立てのために人間として最低限，の仕事をここでしておくのです。
それ以降はAIに対して「ほかエッジケースどういうのがあるかな？」とか聞いていけばテストパターンはどんどん増えていくはずです。量産は AI の得意分野なので任せましょう。ここで更に技術力のある人間であれば，AI が挙げてくれた候補にレビューフィードバックして，精度が上がっていくことも期待できますね。

さて Linter の話に戻りますが，なぜ Linter は適していると考えられるのでしょうか？

業務コード
- 技術的な難易度はそれほど高くなくても，業務固有の要件が発生していることが多く， AI に普遍的なナレッジを教え込むコストが高い
- サービス運用上のリスクとして，金銭的な損失に繋がりうるので，バグの許容度が低い
- 責任が求められる。責任の所在は AI には務まらない

Linter
- 技術的な難易度が高い一方で業務固有の要件は少なめ。広く知れ渡った技術的なベストプラクティスが土台になっていることが多く， AI は最初からそれを理解しており，自走的なサイクルを回してもらいやすい。
- サービス運用上のリスクがない。開発時にバグを踏んでも，一時的に `//xxx:ignore` `TODO: Linter のバグがあるので修正する` 等のコメントをつけるだけで済む
- 責任を取る必要がない。しくじっても誰にも迷惑をかけない

業務コードと少し比較しただけでも，これだけ対象的な性質を持っていますね。付け焼き刃的な Linter なら誰でも作れても， OSS クオリティのお行儀のいい Linter を作るのは難易度が高いし，いちいち業務時間犠牲にしてそこまでやってらんねーよ，ってなるじゃないですか？その仕事， AI が大得意な部分なので任せましょうよ。AI に爆速で作らせて脳汁ドバドバ出して， OSS にしましょう。

更に，この成果物として得られた Linter は，今後人間が書く業務コードだけでなく，AI が書くことになる業務コードも，コード品質が下がらないように下支えしてくれます。「CLAUDE.md, AGENTS.md に書いておけばいいじゃん」が基本ではありますが，その結果保証は100%ではなく確率に左右されてしまいます。Linterの出力は安定しており，入力が同じならあ毎回出力も同じです。普通書かれないようなコードを除き，ミスの検出率をほぼ100%にすることも可能であると思います。

---

## Q3. 具体的な開発体験

**Claude:**

- 開発中に「これは人間だけでは大変だった」と感じた瞬間はありますか？
- AI にどのような指示を出しましたか？
- goroutinectx / zerologlintctx / ctxweaver のうち，どれが最も「Vibe Coding らしい」開発でしたか？

**mpyw:**

> 開発中に「これは人間だけでは大変だった」と感じた瞬間はありますか？
正直 Claude Code (Opus 4.5) + Serena の組み合わせは最強です。連続したタスクから脱線せずに遂行する能力が極めて高いし，とくに Linter 開発においては局所的にも最適解
に近いものを安定して出しているようにすら思います。
構文期のパターンマッチングで大量の switch case をカバーするとか，そういった物量に対応するのは AI が圧倒的に得意だし，その中で求められる高度な知識も惜しみなく披露してくれますね。人間は仕事遅いし詳しくないので AI の圧倒的なスピードの仕事を眺めているだけですｗ

>  - AI にどのような指示を出しましたか？（例: 「zerolog で .Ctx(ctx) が呼ばれていないケースを検出して」など）

ただそれでも無理難題には対応しきれないときはありますね。そういうときに「難しそうなのでやっぱり撤回します，コミットをここまで戻して」とか「難しそうなのでもう少しシンプルなアプローチにしましょう，こういうのはどうですか」とか，その辺の匙加減を知ったうえで提示する能力は人間に求められそうです。あとは，試行錯誤を重ねているとコードがどんどん汚れてくるので，「使わなくなったコードを削除してください」「実装いったん落ちついて，このへんでリファクタリングいれましょうか」「今のコード，フラットに関数並べすぎてるから，認知負荷軽減のためにファイル分割，シンプルな命名にするために構造体メソッド化，あるいは本質的に関心が異なるのであればパッケージ分割して」「名前空間汚染がひどいから，どうしても同じパッケージにこれらの関数をまとめるならプレフィクスをつけて用途を区別できるようにして」とか，そういった指示はよく出していたかなと思います。

>  goroutinectx / zerologlintctx / ctxweaver のうち，どれが最も「Vibe Coding らしい」開発でしたか？

もうこれは全部っすねｗ

----

あとはーなんだろ， Claude Code (Opus 4.5) が優秀すぎるので，初動はあんまり細かく指示出さなくてもほとんど完璧に自走してプロトタイプまでは一瞬で作ってくれるんですけど，そこから先の機能をリッチにしていくフェーズやコード品質を挙げていくフェーズでは色々とプロンプトテクニックは求められると思います。私が愛用していた一つのプロンプトの中に含まれるペルソナが

「徹底的にエッジケースをつつきまくるQAエンジニア。実装エンジニアに対してこれでもかというぐらい複雑な嫌がらせのテストケースを網羅的にぶつける」
「優秀な実装エンジニア。QAエンジニアの無理難題に対応できる高度な技術力を持っている」
「設計に口うるさく潔癖症なリファクタリングエンジニア。デザインパターン，特に Linter 開発においては Strategy Pattern と Visitor Pattern が大好き。Go 哲学を曲解した過度なフラットパッケージや名前空間汚染が大嫌いで，付け焼き刃で適当なコードが書かれていると積極的にメソッド化・パッケージ分割・プレフィクス付与などの対策を要求する」

といった感じの「QAエンジニア」「実装エンジニア」「リファクタリングエンジニア（テックリード的な）」の3人で，これらの特徴を伝えて「このメンバーでサイクルを5回回して。今からお風呂入ってくるからその間勝手にやっといて」
って伝えて数十分ごに戻ってくると，（いい意味で）とんでもない高品質なものが出来上がってたりしますｗ

ただこれでもやっぱり漏れはあるので，コードカバレッジは徹底的に計測するようにして，カバレッジ漏れてるところのテストを指示したりとか，試行錯誤の過程でデッドコード出来上がってたりするので，カバレッジ0%のところは必要性を再検討して使ってなかったら消して，とかそんな感じに指示は出します。

---

## Q4. 人間に残る仕事とは？

**Claude:** 「それでも必要な人間の仕事」も「プロンプト化すればいいじゃん」って言われそうですね。

「ふわっとした整合性」って例えばどういう場面で感じましたか？

思いつく候補：
- **命名の一貫性**: 「この関数名、他と雰囲気違くない？」みたいな違和感
- **抽象度のバランス**: 「ここだけ妙に具体的すぎる/抽象的すぎる」
- **コンテキストを跨いだ判断**: 「この変更、別ファイルのあの設計思想と矛盾してない？」
- **"なんか嫌"の言語化**: 動くけど気持ち悪い、でも何が気持ち悪いか説明できない
- **将来の拡張性の嗅覚**: 「これ後で絶対困るやつ」

**mpyw:** いやーすごい！！まさにそのへんだよ。てか Claude Code が優秀すぎて思考の過程で「ん？これはおかしい。この関数の目的は…だったはずだから，こう改修してしまうと元の目的から脱線してしまう」とか自分からミスに気づくことが多かった点なんだよね。Claude Code + Opus 4.5 のこういう能力は革命的だと思う

---

## Q5. AI の自己修正能力

**Claude:** なるほど！！それ超重要なポイントですね。

つまり構図としては：

### 従来の認識
「ふわっとした整合性は人間の仕事」

### 実際に起きたこと
Claude Code (Opus 4.5) が **自分で気づく**
> 「ん？これはおかしい。この関数の目的は…だったはずだから，こう改修してしまうと元の目的から脱線してしまう」

### 革命的な点
- AI が「自己修正」できるようになった
- 人間が違和感を指摘する前に AI 側から軌道修正が入る
- じゃあ人間の仕事って…？

**それでも「人間がいないと回らない」と感じた瞬間ってありましたか？**

例えば：
- AI が自信満々で間違った方向に突き進んでたとき
- 「いや、そもそもこの機能いらなくね？」という判断
- ユーザー（利用者）の気持ちを想像する部分
- 「このライブラリ、世に出す価値あるか？」の意思決定

あるいは逆に、「マジで人間いらなくね？」って思った瞬間でもいいですｗ

---

## Q6. AI が泥沼にはまった瞬間 / シンプルな割り切り

**Claude:**

1. gormreuse 以外にも「AI が泥沼にはまった」エピソードってありますか？
2. 逆に「AI がシンプルな割り切りを提案してきて感心した」みたいな瞬間は？
3. 1〜2週間で作った「ライブラリ5本」って具体的に何ですか？

**mpyw:**

1. gormreuse 以外にも「AI が泥沼にはまった」エピソードってありますか？

あった気がするけどこれがダントツでやばかったな

2. 逆に「AI がシンプルな割り切りを提案してきて感心した」みたいな瞬間は？

zerologlintctx での https://github.com/mpyw/zerologlintctx/commit/9ca7fc18245f4fd1222e922e7d6a75237eb40cd8 の対応かなぁ。
これ絶対複雑になるやん？って思ったけどそんなことなかったみたい。

（※ このコミットは SSA トレーシングの改善で、Alloc トレーシング・Nil Phi エッジのスキップ・メソッド値の検出という3つの機能追加。複雑になりそうに見えて、シンプルな実装で済んだ）

3. あと成果物の話ですが、1〜2週間で作った「ライブラリ5本」って具体的に何ですか？（ctxweaver, goroutinectx, zerologlintctx, gormreuse, あと1つ？）

feature ってやつです。コンテキストのボイラープレートをジェネリクスで削減するやつ。

---

## インタビュー終了

以上の内容をもとに記事を作成。
